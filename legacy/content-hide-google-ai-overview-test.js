// content-hide-google-ai-overview.js — UnAIfy (conservative: only hide if AI cues are inside the module)
(() => {
  "use strict";

  const MARK = "data-unAIfy-sge-hidden";
  const DEBUG = false; // set true to log candidates

  // Lowercased phrases commonly found around the AI Overview block
  const LABELS = [
    "ai overview",
    "from ai overviews",
    "overview generated by ai",
    "generative ai is experimental",
    "learn more about ai overviews",
    "learn about ai overviews",
    "ai overviews are experimental",
    "ai previews are experimental"
  ];

  // Links Google uses for the “learn more” about AI Overviews (patterns)
  const LINK_PATTERNS = [
    /support\.google\.com\/websearch/i,
    /learn.*ai[- ]?overviews?/i
  ];

  // Only module-sized containers (NEVER hide page wrappers)
  const MODULE_SELECTORS = [
    ".Ww4FFb",
    ".MjjYud",
    ".xpd",
    "[data-sokoban-container]",
    "[data-hveid]",
    ".g"
  ].join(", ");

  // ---- storage helper ----
  const storage = { get: (k) => new Promise((res) => chrome.storage.sync.get(k, res)) };

  let enabled = true;
  let observer = null;
  let lastUrl = location.href;

  // ---- utils ----
  const strip = (s) => (s || "").trim();
  const lc = (s) => strip(s).toLowerCase();

  function hasAILabelText(root) {
    const text = lc(root.innerText || root.textContent || "");
    return text && LABELS.some((lbl) => text.includes(lbl));
  }

  function hasAILearnLink(root) {
    const links = root.querySelectorAll("a[href]");
    for (const a of links) {
      const href = a.getAttribute("href") || "";
      if (LINK_PATTERNS.some((re) => re.test(href))) return true;
      const t = a.textContent || "";
      if (/ai[- ]overviews?/i.test(t)) return true;
    }
    return false;
  }

  function isBigWrapper(el) {
    if (!el) return true;
    const tag = (el.tagName || "").toLowerCase();
    return (
      el === document.body ||
      el === document.documentElement ||
      el.id === "search" ||
      el.id === "rcnt" ||
      tag === "main"
    );
  }

  function nearestModule(el) {
    if (!el) return null;
    const moduleEl = el.closest(MODULE_SELECTORS);
    if (!moduleEl || isBigWrapper(moduleEl)) return null;
    return moduleEl;
  }

  function confidenceAI(moduleEl) {
    // Only count as AI Overview if the *module itself* contains AI cues
    try {
      if (hasAILabelText(moduleEl)) return true;
      if (hasAILearnLink(moduleEl)) return true;
    } catch {}
    return false;
  }

  function hideEl(el) {
    if (!el || el.hasAttribute(MARK)) return;
    el.dataset.unAIfyPrevDisplay = el.style.display || "";
    el.style.display = "none";
    el.setAttribute(MARK, "1");
    if (DEBUG) console.info("[UnAIfy] hid module:", el);
  }

  function unhideAll() {
    document.querySelectorAll("[" + MARK + "]").forEach((el) => {
      el.style.display = el.dataset.unAIfyPrevDisplay || "";
      delete el.dataset.unAIfyPrevDisplay;
      el.removeAttribute(MARK);
    });
  }

  function findAIOverviewModule() {
    const searchRoot = document.querySelector("#search") || document;

    // Candidate modules near the top of the results
    const modules = [...searchRoot.querySelectorAll(MODULE_SELECTORS)].filter((el) => {
      const r = el.getBoundingClientRect?.();
      return r && r.top >= 0 && r.top < 1200; // don’t look too far down
    });

    for (const m of modules) {
      if (isBigWrapper(m)) continue;
      if (confidenceAI(m)) return m; // only accept modules that contain AI cues themselves
      if (DEBUG) console.debug("[UnAIfy] rejected (no AI cues):", m);
    }

    // Extra: look for explicit headings and map to a module
    const headings = searchRoot.querySelectorAll('h1, h2, h3, [role="heading"], [aria-label], span, div');
    for (const h of headings) {
      const t = lc(h.textContent || h.getAttribute?.("aria-label") || "");
      if (!t) continue;
      if (LABELS.some((lbl) => t.includes(lbl))) {
        const mod = nearestModule(h);
        if (mod && confidenceAI(mod)) return mod;
      }
    }

    return null; // fail-safe if unsure
  }

  function hideOnce() {
    if (!enabled) return false;
    const mod = findAIOverviewModule();
    if (!mod) return false;
    hideEl(mod);
    return true;
  }

  function ensureObserver(on) {
    if (on && !observer) {
      observer = new MutationObserver(() => enabled && hideOnce());
      observer.observe(document.documentElement, { childList: true, subtree: true });
    } else if (!on && observer) {
      observer.disconnect();
      observer = null;
    }
  }

  function apply() {
    if (enabled) {
      hideOnce();
      ensureObserver(true);
    } else {
      ensureObserver(false);
      unhideAll();
    }
  }

  // Handle SPA-style URL changes
  function startUrlWatcher() {
    setInterval(() => {
      if (location.href !== lastUrl) {
        lastUrl = location.href;
        unhideAll();
        if (enabled) hideOnce();
      }
    }, 700);
  }

  // Live toggle from popup
  chrome.storage.onChanged.addListener((changes, area) => {
    if (area !== "sync" || !changes.unAIfySettings) return;
    const next = !!changes.unAIfySettings.newValue?.hide_sge;
    if (next !== enabled) {
      enabled = next;
      apply();
    }
  });

  // Init
  (async () => {
    try {
      const { unAIfySettings } = await storage.get("unAIfySettings");
      enabled = !!(unAIfySettings ? unAIfySettings.hide_sge : true);
    } catch {
      enabled = true;
    }
    startUrlWatcher();
    apply();
    setTimeout(() => enabled && hideOnce(), 800);
  })();
})();