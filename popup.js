// Features - These will be connected to content scirpts later
const FEATURES =[
  {
    key: "disable_sge",
    title: "Disable Google AI Overview",
    desc: "Disables Google's AI generated 'Overview' search result box"
  },
  {
    key: "filter_ai_domains",
    title: "WIP: Filter AI-heavy domains",
    desc: "Hide results from blacklisted sites (Editable list)"
  },
 {
    key: "use_uBlockOrigin_blacklist",
    title: "Use uBlockOrigin AI blocklist",
    desc: "Imports and applies uBlockOrigin's public no-AI hosts list (Source: laylavish)"
  },
  {
    key: "warn_post_year",
    title: "WIP: Warning on post-2022 pages",
    desc: "Shows a warning if a page is created/updated after 2022"
  },
  /*
  // TO DO?
  {
    key: "hide_ai_sections",
    title: "Hide 'Generated by AI sections'",
    desc: "Removes AI-labeled blocks inside articles."
  },
  {
    key: "highlight_ai_images",
    title: "Highlights likely AI-generated images",
    desc: "Visually highlights and marks images that may be AI generated"
  }
  */
];


// Defaults
const DEFAULT_BLACKLIST = [
  "perplexity.ai",
  "deepai.org",
  "gemini.google.com",
  "openai.com",
  "aixploria.com",
  "scite.ai"
]

const DEFAULT_CUTOFF_YEAR = 2022;


// DOM
const $ = (sel) => document.querySelector(sel);

let featuresEl, statusEl, resetBtn

// Status helper
function setStatus(text, timeout = 1200) {
  if (!statusEl) return;
  statusEl.textContent = text;
  if (timeout) setTimeout(() => (statusEl.textContent = "Saved"), timeout);
}

// Storage helpers
async function loadSettings() {
  const [{unAIfySettings}, {unAIfyBlacklist}, {unAIfyCutOffYear}] = 
    await Promise.all([
      chrome.storage.sync.get("unAIfySettings"),
      chrome.storage.sync.get("unAIfyBlacklist"),
      chrome.storage.sync.get("unAIfyCutOffYear")
    ]);

  const defaultToggles = Object.fromEntries(FEATURES.map(f => [f.key, true]));
  return{
    toggles: { ...defaultToggles, ...(unAIfySettings || {})},
    blacklist: Array.isArray(unAIfyBlacklist) ? unAIfyBlacklist: DEFAULT_BLACKLIST,
    cutoffyear: Number.isInteger(unAIfyCutOffYear) ? unAIfyCutOffYear: DEFAULT_CUTOFF_YEAR,
  };
}

const saveToggles = (toggles) => chrome.storage.sync.set({unAIfySettings: toggles});
const saveBlacklist = (blacklist) => chrome.storage.sync.set({unAIfyBlacklist: blacklist});
const saveCutOffYear = (cutoffyear) => chrome.storage.sync.set({unAIfyCutOffYear: cutoffyear});

async function syncGoogleSGE(toggles) {
  const on = !!toggles.disable_sge;
  if (!chrome.declarativeNetRequest?.updateEnabledRulesets) return; // Chrome only guard
  if (on) {
    await chrome.declarativeNetRequest.updateEnabledRulesets({ enableRulesetIds: ["google-ai-overview-off-redirect"] });
  } else {
    await chrome.declarativeNetRequest.updateEnabledRulesets({ disableRulesetIds: ["google-ai-overview-off-redirect"] });
  }
}

const GITHUB_HOSTS_URL =
  "https://raw.githubusercontent.com/laylavish/uBlockOrigin-HUGE-AI-Blocklist/main/noai_hosts.txt";

function parseHostsFileToDomains(text) {
  const out = new Set();

  for (let line of (text || "").split(/\r?\n/)) {
    line = line.trim();
    if (!line || line.startsWith("#")) continue;

    // strip inline comments
    line = line.split("#")[0].trim();
    if (!line) continue;

    const parts = line.split(/\s+/);

    // hosts lines usually: "0.0.0.0 www.domain.tld"
    // sometimes just: "domain.tld"
    const candidate = (parts.length === 1) ? parts[0] : parts[parts.length - 1];
    if (!candidate) continue;

    let host = candidate.toLowerCase().replace(/^www\./, "");

    // basic sanity (skip headers like "com" or junk)
    if (!/[a-z0-9-]+\.[a-z0-9.-]+$/.test(host)) continue;

    out.add(host);
  }

  return Array.from(out);
}

async function fetchGithubBlacklistDomains() {
  const res = await fetch(GITHUB_HOSTS_URL, { cache: "no-store" });
  if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
  const txt = await res.text();
  return parseHostsFileToDomains(txt);
}


// Domain utils
function normalizeDomain(input) {
  if (!input) return null;
  let s = input.trim().toLowerCase();
  if (!s) return null;
  s = s.replace(/^https?:\/\//, "");
  s = s.replace(/^www\./, "");
  s = s.split("/")[0].split("?")[0].split("#")[0];
  if (!/[a-z0-9-]+\.[a-z0-9-.]+$/.test(s)) return null;
  return s;
}
function parseDomainTextarea(text) {
  const lines = (text || "").split(/\r?\n/);
  const out = [];
  const seen = new Set();
  for (const line of lines) {
    const dom = normalizeDomain(line);
    if (dom && !seen.has(dom)) { seen.add(dom); out.push(dom); }
  }
  return out;
}
function listToTextarea(list) {
  return (list || []).join("\n");
}

// Render
function render({ toggles, blacklist, cutoffyear }) {
  featuresEl.innerHTML = "";

  FEATURES.forEach((f) => {
    const row = document.createElement("div");
    row.className = "toggle";

    const label = document.createElement("label");
    label.htmlFor = f.key;

    const title = document.createElement("span");
    title.className = "title";
    title.textContent = f.title;

    const desc = document.createElement("span");
    desc.className = "desc";
    desc.textContent = f.desc;

    label.appendChild(title);
    label.appendChild(desc);

    // toggle (checkbox - may change in future)
    const input = document.createElement("input");
    input.type = "checkbox";
    input.id = f.key;

    /// bind + persist toggle
    input.checked = !!toggles[f.key];
    input.addEventListener("change", async () => {
    const newToggles = { ...toggles, [f.key]: input.checked };
    await saveToggles(newToggles);
    toggles[f.key] = input.checked;
    setStatus("Saved");

    if (f.key === "disable_sge") {
      await syncGoogleSGE(newToggles);
    }

    // NEW: pull the GitHub list the moment the user enables it
    if (f.key === "use_uBlockOrigin_blacklist") {
      if (input.checked) {
        try {
          setStatus("Downloading listâ€¦", 0);
          const domains = await fetchGithubBlacklistDomains();
          await chrome.storage.local.set({
            unAIfyGithubBlacklist: domains,
            unAIfyGithubBlacklistFetchedAt: Date.now()
          });
          setStatus(`Imported ${domains.length} domains`);
        } catch (e) {
          console.error(e);
          setStatus("Failed to import list");
          // Optional: auto-disable toggle on failure
          const rollback = { ...newToggles, use_uBlockOrigin_blacklist: false };
          await saveToggles(rollback);
          toggles.use_uBlockOrigin_blacklist = false;
          input.checked = false;
        }
      } else {
        // optional: keep cached list, just disable use
        setStatus("GitHub list disabled");
      }
    }
  });

    row.appendChild(label);
    row.appendChild(input);
    featuresEl.appendChild(row);

    // Editor: Blacklist
    if (f.key === "filter_ai_domains") {
      const editorWrap = document.createElement("div");
      editorWrap.style.margin = "6px 0 4px";

      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.textContent = "Edit blacklist";
      editBtn.className = "btn";
      editorWrap.appendChild(editBtn);

      const panel = document.createElement("div");
      panel.style.display = "none";
      panel.style.marginTop = "8px";
      panel.style.padding = "10px";
      panel.style.border = "1px solid #334155";
      panel.style.borderRadius = "10px";
      panel.style.background = "#0b1220";
      panel.innerHTML = `
        <div style="display:grid; gap:10px;">
          <div>
            <div class="title">Blacklist (one domain per line)</div>
            <textarea id="bl-ta" rows="6" style="width:100%; background:#0a0f1c; color:#e5e7eb; border:1px solid #1f2937; border-radius:8px; padding:8px; resize:vertical;"
              placeholder="example-ai-content.com&#10;another-bot-site.net"></textarea>
            <div class="desc" style="margin-top:6px;">
              No protocols - just <code>domain.tld</code>! 
            </div>
          </div>
          <div style="display:flex; gap:8px; justify-content:flex-end;">
            <button id="cancel-bl" class="btn" type="button">Cancel</button>
            <button id="save-bl" class="btn" type="button">Save blacklist</button>
          </div>
        </div>
      `;
      editorWrap.appendChild(panel);
      featuresEl.appendChild(editorWrap);

      const blTa = () => panel.querySelector("#bl-ta");
      const saveBtn = () => panel.querySelector("#save-bl");
      const cancelBtn = () => panel.querySelector("#cancel-bl");

      function populateTextarea() {
        blTa().value = listToTextarea(blacklist);
      }

      editBtn.addEventListener("click", () => {
        const showing = panel.style.display !== "none";
        if (showing) panel.style.display = "none";
        else {
          populateTextarea();
          panel.style.display = "block";
        }
      });

      cancelBtn().addEventListener("click", () => {
        panel.style.display = "none";
      });

      saveBtn().addEventListener("click", async () => {
        const newBL = parseDomainTextarea(blTa().value);
        await saveBlacklist(newBL);
        blacklist.length = 0; blacklist.push(...newBL);
        setStatus("Blacklist saved");
        panel.style.display = "none";
      });
    }

    // Cutoff Year Editor
    if (f.key === "warn_post_year") {
      const editorWrap = document.createElement("div");
      editorWrap.style.margin = "6px 0 4px";

      const info = document.createElement("div");
      info.className = "desc";
      info.innerHTML = `Cutoff year: <strong id="cutoff-display">${cutoffyear}</strong>`;
      editorWrap.appendChild(info);

      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.textContent = "Change year";
      editBtn.className = "btn";
      editorWrap.appendChild(editBtn);

      const panel = document.createElement("div");
      panel.style.display = "none";
      panel.style.marginTop = "8px";
      panel.style.padding = "10px";
      panel.style.border = "1px solid #334155";
      panel.style.borderRadius = "10px";
      panel.style.background = "#0b1220";
      panel.innerHTML = `
        <div style="display:grid; gap:10px;">
          <label class="title" for="cutoff-input">Set cutoff year</label>
          <input id="cutoff-input" type="number" min="1990" max="2100"
                 style="width:120px; background:#0a0f1c; color:#e5e7eb; border:1px solid #1f2937; border-radius:8px; padding:8px;"
                 value="${cutoffyear}">
          <div class="desc">Pages with an apparent publish/update date after this year will trigger a warning (once you add content scripts).</div>
          <div style="display:flex; gap:8px; justify-content:flex-end;">
            <button id="cancel-cutoff" class="btn" type="button">Cancel</button>
            <button id="save-cutoff" class="btn" type="button">Save year</button>
          </div>
        </div>
      `;
      editorWrap.appendChild(panel);
      featuresEl.appendChild(editorWrap);

      const cutoffDisplay = () => info.querySelector("#cutoff-display");
      const cutoffInput = () => panel.querySelector("#cutoff-input");
      const saveBtn2 = () => panel.querySelector("#save-cutoff");
      const cancelBtn2 = () => panel.querySelector("#cancel-cutoff");

      editBtn.addEventListener("click", () => {
        const showing = panel.style.display !== "none";
        panel.style.display = showing ? "none" : "block";
      });

      cancelBtn2().addEventListener("click", () => {
        panel.style.display = "none";
      });

      saveBtn2().addEventListener("click", async () => {
        let val = parseInt(cutoffInput().value, 10);
        if (!Number.isFinite(val)) val = DEFAULT_CUTOFF_YEAR;
        val = Math.min(2100, Math.max(1990, val));
        await saveCutOffYear(val);
        cutoffyear = val;
        cutoffDisplay().textContent = String(val);
        setStatus("Cutoff year saved");
        panel.style.display = "none";
      });
    }
  });
}

// Init
async function init() {
  featuresEl = document.getElementById("features");
  statusEl = document.getElementById("status");
  resetBtn = document.getElementById("reset")

  if(!featuresEl || !statusEl || !resetBtn) {
    console.error("[UnAIfy] Missing DOM nodes (#features, #status, #reset");
  }

  const state = await loadSettings();
  await syncGoogleSGE(state.toggles);
  render(state);

  resetBtn.addEventListener("click", async () => {
    const defaultToggles = Object.fromEntries(FEATURES.map(f => [f.key, true]));
    await Promise.all([
      saveToggles(defaultToggles),
      saveBlacklist(DEFAULT_BLACKLIST),
      saveCutOffYear(DEFAULT_CUTOFF_YEAR)
    ]);
    await syncGoogleSGE(defaultToggles);
    render({
      toggles: defaultToggles,
      blacklist: [...DEFAULT_BLACKLIST],
      cutoffyear: DEFAULT_CUTOFF_YEAR
    });
    setStatus("Reset to defaults");
  });

  setStatus("Ready", 800);
}

//ensure popup.js runs after DOM
// if popup loads it with 'defer', this is also safe
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", init, {once: true});
} else {
  init();
}
