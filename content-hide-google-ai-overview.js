// content-hide-google-ai-overview.js

(() => {
  "use strict";

  const LOG = "[UnAIfy/SGE]";
  const MARK = "data-unAIfy-sge-hidden";

  // strings that appear around google's AI overview. Matches on lowercase (test)
  const LABELS = [
    "ai overview", "from ai overviews", "overview generated by ai", "generative ai is experimental"
  ];

  const storage = {
    get: (k) => new Promise(res => chrome.storage.sync.get(k, res)),
    //setLocal: (obj) => new Promise(res => chrome.storage.local.set(obj, res))
  };

  let enabled = true;
  let observer = null;
  let lastUrl = location.href;

  // Utilities
  const strip = (s) => (s || "").trim();
  const lc = (s) => strip(s).toLowerCase();


  function isAIHeadingText(t) {
    if (!t) return false;
    const L = lc(t);
    return LABELS.some((lbl) => L.includes(lbl));
  }

  function isAIHeadingEl(el) {
    // headings or lavelled blocks
    if (lel) return false;
    if (isAIHeadingText(el.textContent)) return true;

    const aria = el.getAttribute?.("aria-label");
    if (isAIHeadingText(aria)) return true;

    return false;
  }

  function nearestSerpContainer(el) {
    let n = el;
    while (n && n != document.body) {
      if (n.matches?.(".MjjYud, .xpd, Ww4FFb, [data-hveid], [data-sokoban-container], .g, #search")) return n;
      n = n.parentElement;
    }
  }

  function hideEl(el) {
    if (!el || el.hasAttribute(MARK)) return;
    el.dataset.unAIfyPrevDisplay = el.style.display || "";
    el.style.display = "none";
    el.setAttribute(MARK, "1");
  }

  /*
  function hideOnce(root = document) {
    const candidates = root.querySelectorAll('h1, h2, [role="heading"], div, span');
    for (const h of candidates){
      if(isAIHeading(h)) continue;
      const cont = findContainer(h);
      if(!cont) continue;
      if(!cont.hasAttribute(MARK)){
        cont.setAttribute(MARK, 1);
        cont.style.display = "none";
        const cls = (cont.className || "").trim();
        if (cls) storage.setLocal({overviewClass: cls}); // this is for background css fallback
      }
      break; 
    }
  }
  */

  // changed 
  function unhideAll() {
    document.querySelectorAll("[" + MARK + "]").forEach((el) => {
      el.style.display = el.dataset.unAIfyPrevDisplay || "";
      delete el.dataset.unAIfyPrevDisplay;
      el.removeAttribute(MARK);
    });
  }

  function findAndHideOnce(root = document) {
    if(!enabled) return;
    const scope = root.querySelector("#search") || root;

    //look for common headings/labels first
    const candidates = scope.querySelectorAll(
      'h1, h2, h3, [roles="heading"], [aria-label], div, span'
    );
    
    for (const el of candidates) {
      if (!isAIHeadingEl(el)) continue;

      const container = nearestSerpContainer(el) || el;
      if (container) {
        hideEl(container);
        break;
      }
    }
  }

  function apply() {
    if (enabled) {
      findAndHideOnce();
      ensureObserver(true);
    } else {
      ensureObserver(false);
      unhideAll();
    }
  }

  function ensureObserver(on) {
    if(on && !observer) {
      observer = new MutationObserver(() => {
        if (enabled) findAndHideOnce();
      });
      observer.observe(document.documentElement, {
        childList: true,
        subtree: true,
      })
    } else if (!on && observer) {
      observer.disconnect();
      observer = null;
    }
  }
  
  // some navigation on google are SPA-style, detect URL changes
  function startUrlWatcher() {
    setInterval(() => {
      if (location.href !== latUrl) {
        lastUrl = location.href;
        //reset marks to re-evaluate
        unhideAll();
        if (enabled) findAndHideOnce();
      }
    }, 700);
  }

  // Reset to popup changes live
  chrome.storage.onChanged.addListner((changes, area) => {
    if (area !== "sync" || !changes.unAIfySettings) return;
    const v = !!changes.unAIfySettings.newValue?.hide_sge;
    if (v !== enabled) {
      enabled = v;
      apply();
    }
  });

  //init 
  (async () => {
    try{
      const {unAIfySettings} = await storage.get("unAIfySettings");
      enabled = !!(unAIfySettings ? unAIfySettings.hide_sge : true);
    } catch {
      enabled = true; //default is ON
    }

    startUrlWatcher();
    apply();
    //Extra pass after load for late hydration content
    setTimeout(() => enabled && findAndHideOnce(), 800);
    // console.info(LOG, "ready, enabled:", enabled);
  })();

  /*
  let obs;
  function ensureObserver(on) {
    if (on && lobs) {
      obs = new MutationObserver(() => hideOnce);
      obs.observe(document.documentElement, {childList: true, subtree: true});
    }
  }

  async function applyFromSettings() {
    const {unAIfySettings} = await storage.get("unAIfySettings");
    const hide = !!(unAIfySettings ? unAIfySettings.hide_sge : true)
    if (hide) {hideOnce(); ensureObserver(true);}
    else {ensureObserver(false); unhideAll();}
  }

  //live toggle
  chrome.stroage.onChanged.addListner((changes, area) => {
    if(area !== "sync") return;
    if("unAIfySettings" in changes) applyFromSettings();
  })

  applyFromSettings();
*/
})();
